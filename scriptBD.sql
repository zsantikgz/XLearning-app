-- 1 TABLA DE USUARIOS 
CREATE TABLE USUARIOS (
    ID_USUARIO SERIAL PRIMARY KEY,
    EMAIL VARCHAR(255) UNIQUE NOT NULL,
    CONTRASENA VARCHAR(255) NOT NULL,
    NOMBRE VARCHAR(100) NOT NULL,
    APELLIDOS VARCHAR(100) NOT NULL,
    TIPO_USUARIO VARCHAR(20) NOT NULL CHECK (TIPO_USUARIO IN ('ESTUDIANTE', 'PROFESOR', 'ADMINISTRADOR')),
    TELEFONO VARCHAR(20),
    MATRICULA VARCHAR(50) UNIQUE,
    FECHA_CREAICION TIMESTAMP DEFAULT NOW(),
    FECHA_ACTUALIZACION TIMESTAMP DEFAULT NOW()
);

-- 2 TABLA CLASES
CREATE TABLE CLASES (
    ID_CLASE SERIAL PRIMARY KEY,
    NOMBRE VARCHAR(100) NOT NULL,
    ID_PROFESOR INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    NIVEL_ACADEMICO VARCHAR(50),
    FECHA_CREACION TIMESTAMP DEFAULT NOW(),
    FECHA_ACTUALIZACION TIMESTAMP DEFAULT NOW()
);

-- 3 TABLA ESTUDIANTES_CLASES
CREATE TABLE ESTUDIANTES_CLASES(
    ID_ESTUDIANTE_CLASE SERIAL PRIMARY KEY,
    ID_ESTUDIANTE INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    ID_CLASE INT NOT NULL REFERENCES CLASES(ID_CLASE) ON DELETE CASCADE,
    FECHA_INSCRIPCION DATE DEFAULT NOW()
);

-- 4 TABLA ASISTENCIAS_CLASES
CREATE TABLE ASISTENCIAS_CLASES (
    ID_ASISTENCIA SERIAL PRIMARY KEY,
    ID_CLASE INT NOT NULL REFERENCES CLASES(ID_CLASE),
    ID_ESTUDIANTE INT NOT NULL REFERENCES USUARIOS(ID_USUARIO),
    FECHA DATE NOT NULL,
    PRESENTE BOOLEAN NOT NULL, -- TRUE = PRESENTE, FALSE = AUSENTE
    JUSTIFICACION TEXT,
    CREADO_EN TIMESTAMP DEFAULT NOW()
);

-- 5 TABLA PARTICIPACIONES_CLASES
CREATE TABLE PARTICIPACIONES_CLASES (
    ID_PARTICIPACIONES SERIAL PRIMARY KEY,
    ID_CLASE INT NOT NULL REFERENCES CLASES(ID_CLASE),
    ID_ESTUDIANTE INT NOT NULL REFERENCES USUARIOS(ID_USUARIO),
    FECHA DATE NOT NULL,
    CANTIDAD INT NOT NULL CHECK (CANTIDAD >= 0), -- NUMERO DE PARTICIPACIONES
    TIPO VARCHAR(50), -- EJ: PREGUNTA, COMENTARIO, EJERCICIO
    DETALLES TEXT,
    CREADO_EN TIMESTAMP DEFAULT NOW()
);

-- 6 TABLA ASIGNACIONES (TAREAS/ACTIVIDADES)
CREATE TABLE ASIGNACIONES (
    ID_ASIGNACION SERIAL PRIMARY KEY,
    ID_CLASE INT NOT NULL REFERENCES CLASES(ID_CLASE) ON DELETE CASCADE,
    TITULO VARCHAR(255) NOT NULL,
    DESCRIPCION TEXT,
    FECHA_ENTREGA TIMESTAMP NOT NULL,
    CALIFIACACION_MAXIMA INT NOT NULL,
    FECHA_CREAACION TIMESTAMP DEFAULT NOW(),
    URL_ARCHIVO VARCHAR(255)
);

ALTER TABLE ASIGNACIONES
ADD COLUMN ID_PROFESOR INT REFERENCES USUARIOS(ID_USUARIO);


-- 7 ENTREGAS_ASIGNACIONES
CREATE TABLE ENTREGAS_ASIGNACIONES (
    ID_ENTREGA SERIAL PRIMARY KEY,
    ID_ASIGNACION INT NOT NULL REFERENCES ASIGNACIONES(ID_ASIGNACION) ON DELETE CASCADE,
    ID_ESTUDIANTE INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    URL_ENTREGA VARCHAR(255) NOT NULL,
    FECHA_ENTREGA TIMESTAMP DEFAULT NOW()
);

-- 8 TABLA CALIFICACIONES (REGISTRO DE NOTAS)
CREATE TABLE CALIFICACIONES (
    ID_CALIFICACION SERIAL PRIMARY KEY,
    ID_ASIGNACION INT NOT NULL REFERENCES ASIGNACIONES(ID_ASIGNACION) ON DELETE CASCADE,
    ID_ESTUDIANTE INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    CALIFICACION DECIMAL(5,2) CHECK (CALIFICACION >= 0),
    COMENTARIO TEXT,
    FECHA_CALIFICACION TIMESTAMP DEFAULT NOW()
);

ALTER TABLE CALIFICACIONES
ADD COLUMN VALOR_TOKENS INT DEFAULT 0 CHECK (VALOR_TOKENS >= 0);


-- 9 TABLA EVENTOS (CALENDATIO ACADEMICO)
CREATE TABLE EVENTOS (
    ID_EVENTO SERIAL PRIMARY KEY,
    TITULO VARCHAR(255) NOT NULL,
    DESCRIPCION TEXT,
    TIEMPO_INICIO TIMESTAMP NOT NULL,
    TIEMPO_TERMINO TIMESTAMP NOT NULL,
    ID_CLASE INT NOT NULL REFERENCES CLASES(ID_CLASE) ON DELETE CASCADE,
    CREADO_POR INT REFERENCES USUARIOS(ID_USUARIO) ON DELETE SET NULL,
    TOKENS_OTORGADOS INT DEFAULT 0
);

-- 10 TABLA ASISTENCIA_EVENTOS (REGISTRO DE ASISTENCIA A EVENTOS)
CREATE TABLE ASISTENCIA_EVENTOS (
    ID_ASISTENCIA SERIAL PRIMARY KEY,
    ID_EVENTO INT NOT NULL REFERENCES EVENTOS(ID_EVENTO) ON DELETE CASCADE,
    ID_USUARIO INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    ASISTENCIA BOOLEAN NOT NULL DEFAULT FALSE,
    FECHA_REGISTRO TIMESTAMP DEFAULT NOW()
);

-- 11 TABLA RECOMPENSAS (CATALOGO DE PREMIOS)
CREATE TABLE RECOMPENSAS (
    ID_RECOMPENSA SERIAL PRIMARY KEY,
    NOMBRE VARCHAR(100) NOT NULL,
    DESCRIPCION TEXT,
    COSTO_TOKENS INT NOT NULL CHECK (COSTO_TOKENS > 0),
    ACTIVO BOOLEAN NOT NULL DEFAULT TRUE,
    FECHA_CREACION TIMESTAMP DEFAULT NOW()
);

ALTER TABLE RECOMPENSAS
ADD COLUMN IMAGEN_URL VARCHAR(255);


-- 12 TABLA USUARIO_TOKENS (SALDO DE TOKENS POR USUARIO)
CREATE TABLE USUARIO_TOKENS (
    ID_USUARIO_TOKENS SERIAL PRIMARY KEY,
    ID_USUARIO INT NOT NULL REFERENCES USUARIOS (ID_USUARIO),
    BALANCE INT DEFAULT 0 CHECK (BALANCE >= 0),
    ULTIMA_ACTUALIZACION TIMESTAMP DEFAULT NOW()
);

-- 13 TABLA TRANSACCION_TOKENS (HISTORIAL DE TRANSACCIONES)
CREATE TABLE TRANSACCION_TOKENS(
    ID_TRANSACCION SERIAL PRIMARY KEY,
    ID_USUARIO INT NOT NULL REFERENCES USUARIOS(ID_USUARIO),
    MONTO INT NOT NULL,
    TIPO VARCHAR(20) NOT NULL CHECK (TIPO IN ('GANADO', 'GASTADO')),
    ID_REFERENCIA INT, -- PUEDE SER ID_EVENTO, ID_ASIGNACION, ETC.
    TIPO_REFERENCIA VARCHAR(50) -- 'EVENTO', 'ASIGNACION', 'RECOMPENSA'
    FECHA TIMESTAMP DEFAULT NOW()
);

-- 14 TABLA ANUNCIOS (COMUNICADOS)
CREATE TABLE ANUNCIOS (
    ID_ANUNCIO SERIAL PRIMARY KEY,
    ID_CLASE INT REFERENCES CLASES(ID_CLASE),
    TITULO VARCHAR (255) NOT NULL,
    DESCRIPCION TEXT,
    FECHA_CREACION TIMESTAMP DEFAULT NOW()
);

-- 15 TABLA CERTIFICACIONES (LOGROS DE ESTUDIANTES)
CREATE TABLE CERTIFICACIONES (
    ID_CERTIDICADO SERIAL PRIMARY KEY,
    ID_USUARIO INT NOT NULL REFERENCES USUARIOS (ID_USUARIO),
    TITULO VARCHAR(255) NOT NULL,
    FECHA_OBTENCION DATE NOT NULL,
    URL_DOCUMENTO VARCHAR (255)
);

-- 16 TABLA CANJE RECOMPENSAS
CREATE TABLE CANJE_RECOMPENSAS (
    ID_CANJE SERIAL PRIMARY KEY,
    ID_USUARIO INT NOT NULL REFERENCES USUARIOS(ID_USUARIO) ON DELETE CASCADE,
    ID_RECOMPENSA INT NOT NULL REFERENCES RECOMPENSAS(ID_RECOMPENSA) ON DELETE CASCADE,
    FECHA_CANJE TIMESTAMP DEFAULT NOW(),
    ESTADO VARCHAR(20) DEFAULT 'PENDIENTE' CHECK (ESTADO IN ('PENDIENTE', 'ENTREGADO', 'CANCELADO')),
    COMENTARIO TEXT
);

---------------------- VISTAS ------------------------

-- VISTA: RESUMEN ACADEMICO POR ESTUDIANTE
CREATE OR REPLACE VIEW VISTA_RESUMEN_ESTUDIANTE AS 
SELECT
    U.ID_USUARIO,
    U.NOMBRE || ' ' || U.APELLIDOS AS ESTUDIANTE,
    C.NOMBRE AS CLASE,
    COUNT(DISTINCT A.ID_ASIGNACION) AS TAREAS_ASIGNADAS,
    COUNT(DISTINCT E.ID_ENTREGA) AS TAREAS_ENTREGADAS,
    AVG(G.CALIFICACION) AS PROMEDIO_GENERAL,
    COUNT(CASE WHEN AC.PRESENTE = TRUE THEN 1 END) AS DIAS_PRESENTE,
    COUNT(AC.ID_ASISTENCIA) AS TOTAL_CLASES,
    COALESCE(SUM(PC.CANTIDAD), 0) AS TOTAL_PARTICIPACIONES
FROM USUARIOS U
JOIN ESTUDIANTES_CLASES EC ON U.ID_USUARIO = EC.ID_ESTUDIANTE
JOIN CLASES C ON EC.ID_CLASE = C.ID_CLASE
LEFT JOIN ASIGNACIONES A ON C.ID_CLASE = A.ID_CLASE
LEFT JOIN ENTREGAS_ASIGNACIONES E ON A.ID_ASIGNACION = E.ID_ASIGNACION AND E.ID_ESTUDIANTE = U.ID_USUARIO
LEFT JOIN CALIFICACIONES G ON A.ID_ASIGNACION = G.ID_ASIGNACION AND G.ID_ESTUDIANTE = U.ID_USUARIO
LEFT JOIN ASISTENCIAS_CLASES AC ON U.ID_USUARIO = AC.ID_ESTUDIANTE AND AC.ID_CLASE = C.ID_CLASE
LEFT JOIN PARTICIPACIONES_CLASES PC ON U.ID_USUARIO = PC.ID_ESTUDIANTE AND PC.ID_CLASE = C.ID_CLASE
GROUP BY U.ID_USUARIO, C.ID_CLASE;

-- VISTA: VISTA DE ASISTENCIAS DETALLADAS
CREATE OR REPLACE VIEW VISTA_ASISTENCIAS_DETALLADAS AS
SELECT
    C.NOMBRE AS CLASE,
    U.NOMBRE || ' ' || U.APELLIDOS AS ESTUDIANTE,
    AC.FECHA,
    CASE WHEN AC.PRESENTE THEN 'PRESENTE' ELSE 'AUSENTE' END AS ESTADO,
    AC.JUSTIFICACION,
    COALESCE(SUM(PC.CANTIDAD), 0) AS PARTICIPACIONES_DIA
FROM ASISTENCIAS_CLASES AC
JOIN USUARIOS U ON AC.ID_ESTUDIANTE = U.ID_USUARIO
JOIN CLASES C ON AC.ID_CLASE = C.ID_CLASE
LEFT JOIN PARTICIPACIONES_CLASES PC ON AC.ID_ESTUDIANTE = PC.ID_ESTUDIANTE
                                    AND AC.ID_CLASE = PC.ID_CLASE
                                    AND AC.FECHA = PC.FECHA
GROUP BY C.NOMBRE, U.NOMBRE, U.APELLIDOS, AC.FECHA, AC.PRESENTE, AC.JUSTIFICACION

-- VISTA: EVENTOS CON ASISTENCIA
CREATE OR REPLACE VIEW VISTA_EVENTOS_ASISTENCIA AS
SELECT
    E.ID_EVENTO,
    E.TITULO,
    E.TIEMPO_INICIO,
    C.NOMBRE AS CLASE,
    COUNT(CASE WHEN AE.ASISTENCIA = TRUE THEN 1 END) AS ASISTENTES,
    COUNT(AE.ID_ASISTENCIA) AS TOTAL_INSCRITOS
FROM EVENTOS E
LEFT JOIN CLASES C ON E.ID_CLASE = C.ID_CLASE
LEFT JOIN ASISTENCIA_EVENTOS AE ON E.ID_EVENTO = AE.ID_EVENTO
GROUP BY E.ID_EVENTO, C.NOMBRE;


CREATE OR REPLACE VIEW VISTA_CUADRO_HONOR AS
SELECT 
    u.id_usuario,
    u.nombre || ' ' || u.apellidos AS estudiante,
    ROUND(AVG(c.calificacion), 2) AS promedio_general,
    COUNT(DISTINCT a.id_asignacion) AS total_asignaciones,
    COUNT(c.id_calificacion) AS tareas_calificadas
FROM usuarios u
JOIN calificaciones c ON u.id_usuario = c.id_estudiante
JOIN asignaciones a ON c.id_asignacion = a.id_asignacion
WHERE u.tipo_usuario = 'ESTUDIANTE'
GROUP BY u.id_usuario, u.nombre, u.apellidos
ORDER BY promedio_general DESC;


CREATE OR REPLACE VIEW VISTA_CUADRO_HONOR_GENERAL AS
SELECT 
    u.id_usuario,
    u.nombre || ' ' || u.apellidos AS estudiante,
    ROUND(AVG(c.calificacion), 2) AS promedio_general,
    COUNT(c.id_calificacion) AS tareas_calificadas
FROM usuarios u
JOIN calificaciones c ON u.id_usuario = c.id_estudiante
WHERE u.tipo_usuario = 'ESTUDIANTE'
GROUP BY u.id_usuario, u.nombre, u.apellidos
ORDER BY promedio_general DESC;


CREATE OR REPLACE VIEW VISTA_CUADRO_HONOR_CLASE AS
SELECT 
    u.id_usuario,
    a.id_clase,
    cl.nombre AS clase,
    u.nombre || ' ' || u.apellidos AS estudiante,
    ROUND(AVG(c.calificacion), 2) AS promedio_clase,
    COUNT(c.id_calificacion) AS tareas_calificadas
FROM usuarios u
JOIN calificaciones c ON u.id_usuario = c.id_estudiante
JOIN asignaciones a ON c.id_asignacion = a.id_asignacion
JOIN clases cl ON a.id_clase = cl.id_clase
WHERE u.tipo_usuario = 'ESTUDIANTE'
GROUP BY u.id_usuario, a.id_clase, cl.nombre, u.nombre, u.apellidos
ORDER BY promedio_clase DESC;

--------------------- TRIGGERS --------------------------
-- VALIDAR FECHA DE ASISTENCIAS (NO FUTURAS)
CREATE OR REPLACE FUNCTION VALIDAR_FECHA_ASISTENCIA()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.FECHA > CURRENT_DATE THEN
        RAISE EXCEPTION 'LA FECHA DE ASISTENCIA NO PUEDE SER FUTURA';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_VALIDAR_FECHA_ASISTENCIA
BEFORE INSERT OR UPDATE ON ASISTENCIAS_CLASES
FOR EACH ROW EXECUTE FUNCTION VALIDAR_FECHA_ASISTENCIA();

-- SINCRONIZAR PARTICIPACIONES CON ASISTENCIAS
CREATE OR REPLACE FUNCTION SINCRONIZAR_PARTICIPACION_ASISTENCIA()
RETURNS TRIGGER AS $$
BEGIN
    -- SI SE REGISTRA PARTICIPACIONES, ASEGURAR QUE EXISTE REGISTRO DE ASISTENCIA
    IF NOT EXISTS (
        SELECT 1 FROM ASISTENCIAS_CLASES
        WHERE ID_ESTUDIANTE = NEW.ID_ESTUDIANTE
            AND ID_CLASE = NEW.ID_CLASE
            AND FECHA = NEW.FECHA
    ) THEN INSERT INTO ASISTENCIAS_CLASES (ID_CLASE, ID_ESTUDIANTE, FECHA, PRESENTE, JUSTIFICACION)
        VALUES (NEW.ID_CLASE, NEW.ID_ESTUDIANTE, NEW.FECHA, TRUE, 'AUTOMATICO POR PARTICIPACION');
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_SINCRONIZAR_PARTICIPACION
BEFORE INSERT ON PARTICIPACIONES_CLASES
FOR EACH ROW EXECUTE FUNCTION SINCRONIZAR_PARTICIPACION_ASISTENCIA();


-- ACTUALIZAR FECHA DE MODIFICACION AUTOMATICAMENTE
CREATE OR REPLACE FUNCTION ACTUALIZAR_TIMESTAMP()
RETURNS TRIGGER AS $$
BEGIN
    NEW.FECHA_ACTUALIZACION = NOW();
    RETURN NEW;
END;
$$ LANGUAGE PLPSQL;

CREATE TRIGGER TRIGGER_ACTUALIZAR_USUARIO
BEFORE UPDATE ON USUARIOS
FOR EACH ROW EXECUTE FUNCTION ACTUALIZAR_TIMESTAMP();

-- VALIDAR ROL DE USUARIO AL MATRICULAR
CREATE OR REPLACE FUNCTION VALIDAR_MATRICULA()
RETURNS TRIGGER AS $$
BEGIN
    IF (SELECT TIPO_USUARIO FROM USUARIOS WHERE ID_USUARIO = NEW.ID_ESTUDIANTE) != 'ESTUDIANTE'
THEN
        RAISE EXCEPTION 'SOLO LOS ESTUDIANTES PUEDEN SER MATRICULADOS EN CLASES';
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_VALIDAR_MATRICULA
BEFORE INSERT ON ESTUDIANTES_CLASES
FOR EACH ROW EXECUTE FUNCTION VALIDAR_MATRICULA();

-- ACTUALIZAR BALANCE DE TOKEN AUTOMATICAMENTE
CREATE OR REPLACE FUNCTION ACTUALIZAR_BALANCE_TOKENS()
RETURNS TRIGGER AS $$
BEGIN
    IF NEW.TIPO = 'GANADO' THEN
        UPDATE USUARIO_TOKENS
        SET BALANCE = BALANCE + NEW.MONTO,
            ULTIMA_ACTUALIZACION = NOW()
        WHERE ID_USUARIO = NEW.ID_USUARIO;
    ELSE
        UPDATE USUARIO_TOKENS
        SET BALANCE = BALANCE - NEW.MONTO,
            ULTIMA_ACTUALIZACION = NOW()
        WHERE ID_USUARIO = NEW.ID_USUARIO;
    END IF;
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_ACTUALIZAR_TOKENS
AFTER INSERT ON TRANSACCION_TOKENS
FOR EACH ROW EXECUTE FUNCTION ACTUALIZAR_BALANCE_TOKENS();


-- ACTUALIZAR USUARIO
CREATE OR REPLACE FUNCTION ACTUALIZAR_TIMESTAMP()
RETURNS TRIGGER AS $$
BEGIN
    NEW.FECHA_ACTUALIZACION = NOW();
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_ACTUALIZAR_USUARIO
BEFORE UPDATE ON USUARIOS
FOR EACH ROW
EXECUTE FUNCTION ACTUALIZAR_TIMESTAMP();

-- ACTUALIZAR CLASES
CREATE OR REPLACE FUNCTION ACTUALIZAR_CLASES()
RETURNS TRIGGER AS $$
BEGIN
    NEW.FECHA_ACTUALIZACION = NOW();
    RETURN NEW;
END;
$$ LANGUAGE PLPGSQL;

CREATE TRIGGER TRIGGER_ACTUALIZAR_CLASES
BEFORE UPDATE ON CLASES
FOR EACH ROW
EXECUTE FUNCTION ACTUALIZAR_CLASES


CREATE OR REPLACE FUNCTION fn_otorgar_tokens_asistencia_evento()
RETURNS TRIGGER AS $$
DECLARE
    tokens_evento INT;
BEGIN
    -- Solo otorgar tokens si la asistencia fue confirmada como TRUE
    IF NEW.ASISTENCIA IS NOT TRUE THEN
        RETURN NEW;
    END IF;

    -- Obtener tokens otorgados por el evento
    SELECT TOKENS_OTORGADOS INTO tokens_evento
    FROM EVENTOS
    WHERE ID_EVENTO = NEW.ID_EVENTO;

    -- Si el evento no existe o no otorga tokens, salir
    IF tokens_evento IS NULL OR tokens_evento <= 0 THEN
        RETURN NEW;
    END IF;

    -- Asegurar que el usuario tenga registro en USUARIO_TOKENS
    INSERT INTO USUARIO_TOKENS (ID_USUARIO, BALANCE)
    VALUES (NEW.ID_USUARIO, 0)
    ON CONFLICT (ID_USUARIO) DO NOTHING;

    -- Registrar transacción
    INSERT INTO TRANSACCION_TOKENS (
        ID_USUARIO,
        MONTO,
        TIPO,
        ID_REFERENCIA,
        TIPO_REFERENCIA
    ) VALUES (
        NEW.ID_USUARIO,
        tokens_evento,
        'GANADO',
        NEW.ID_EVENTO,
        'EVENTO'
    );

    -- Actualizar el balance
    UPDATE USUARIO_TOKENS
    SET BALANCE = BALANCE + tokens_evento,
        ULTIMA_ACTUALIZACION = NOW()
    WHERE ID_USUARIO = NEW.ID_USUARIO;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_otorgar_tokens_asistencia
AFTER INSERT ON ASISTENCIA_EVENTOS
FOR EACH ROW
EXECUTE FUNCTION fn_otorgar_tokens_asistencia_evento();



CREATE OR REPLACE FUNCTION fn_otorgar_tokens_por_calificacion()
RETURNS TRIGGER AS $$
DECLARE
    tokens INT := 0;
BEGIN
    -- Obtener los tokens otorgados por esta calificación
    tokens := NEW.VALOR_TOKENS;

    -- Si no hay tokens que otorgar, salir
    IF tokens IS NULL OR tokens <= 0 THEN
        RETURN NEW;
    END IF;

    -- Asegurar que el estudiante tenga entrada en USUARIO_TOKENS
    INSERT INTO USUARIO_TOKENS (ID_USUARIO, BALANCE)
    VALUES (NEW.ID_ESTUDIANTE, 0)
    ON CONFLICT (ID_USUARIO) DO NOTHING;

    -- Registrar la transacción
    INSERT INTO TRANSACCION_TOKENS (
        ID_USUARIO, MONTO, TIPO, ID_REFERENCIA, TIPO_REFERENCIA
    ) VALUES (
        NEW.ID_ESTUDIANTE,
        tokens,
        'GANADO',
        NEW.ID_CALIFICACION,
        'CALIFICACION'
    );

    -- Actualizar el balance
    UPDATE USUARIO_TOKENS
    SET BALANCE = BALANCE + tokens,
        ULTIMA_ACTUALIZACION = NOW()
    WHERE ID_USUARIO = NEW.ID_ESTUDIANTE;

    RETURN NEW;
END;
$$ LANGUAGE plpgsql;


CREATE TRIGGER trg_otorgar_tokens_por_calificacion
AFTER INSERT ON CALIFICACIONES
FOR EACH ROW
EXECUTE FUNCTION fn_otorgar_tokens_por_calificacion();

---------------- PROCEDIMIENTOS ---------------------------

-- REGISTRAR ASISTENCIA MASIVA CON PARTICIPACIONES
CREATE OR REPLACE PROCEDURE REGISTRAR_ASISTENCIA_PARTICIPACION(
    P_ID_CLASE INT,
    P_FECHA DATE,
    P_ESTUDIANTES_PRESENTES INT[],
    P_PARTICIPACIONES JSON -- EJ: '[{"id_estudiante": 101, "cantidad": 3}, {...}]'
)
LANGUAGE PLPGSQL AS $$
DECLARE
    V_ESTUDIANTE RECORD;
BEGIN
    -- REGISTRAR ASISTENCIAS
    INSERT INTO ASISTENCIAS_CALSES (ID_CLASE, ID_ESTUDIANTE, FECHA, PRESENTE)
    SELECT P_ID_CLASE, ID_ESTUDIANTE, P_FECHA TRUE
    FROM UNNEST(P_ESTUDIANTES_PRESENTES) AS ID_ESTUDIANTE
    ON CONFLICT (ID_CLASE, ID_ESTUDIANTE, FECHA) DO UPDATE SET PRESENTE = TRUE;

    -- REGUSTRAR PARTICIPACIONES
    FOR V_ESTUDIANTE IN SELECT * FROM JSON_ARRAY_ELEMENTS(P_PARTICIPACIONES) AS P
    LOOP
        INSERT INTO PARTICIPACIONES_CLASES (ID_CLASE, ID_ESTUDIANTE, FECHA, CANTIDAD)
        VALUES (
            P_ID_CLASE,
            (V_ESTUDIANTE->>'ID_ESTUDIANTE')::INT,
            P_FECHA,
            (V_ESTUDIANTE->>'CANTIDAD')::INT
        );
    END LOOP;
END;
$$;

--GENERAR REPORTE DE PARTICIPACION POR CLASE
CREATE OR REPLACE PROCEDURE GENERAR_REPORTE_PARTICIPACION(
    P_ID_CLASE INT,
    OUT TOTAL_ESTUDIANTES INT,
    OUT PROMEDIO_PARTICIPACIONES DECIMAL (5,2),
    OUT TOP_PARTICIPANTE TEXT
)
LANGUAGE PLPGSQL AS $$
BEGIN
    -- TOTAL DE ESTUDIANTES
    SELECT COUNT(*) INTO TOTAL_ESTUDIANTES
    FROM ESTUDIANTES_CLASES
    WHERE ID_CLASE = P_ID_CLASE;

    -- PROMEDIO DE PARTICIPACIONES
    SELECT AVG(CANTIDAD) INTO PROMEDIO_PARTICIPACIONES
    FROM PARTICIPACIONES_CLASES
    WHERE ID_CLASE = P_ID_CLASE;

    -- TOP  PARTICIPANTE
    SELECT NOMBRE || ' ' || APELLIDOS INTO TOP_PARTICIPANTE
    FROM(
        SELECT U.NOMBRE, U.APELLIDOS, SUM(PC.CANTIDAD) AS TOTAL
        FROM PARTICIPACIONES_CLASES PC
        JOIN USUARIOS U ON PC.ID_ESTUDIANTE = U.ID_USUARIO
        WHERE PC.ID_CLASE = P_ID_CLASE
        GROUP BY U.ID_USUARIO
        ORDER BY TOTAL DESC
        LIMIT 1
    ) AS TOP;
END;
$$;


-- REGISTRAR ASISTENCIA MASIVA A EVENTOS
CREATE OR REPLACE PROCEDURE REGISTRAR_ASISTENCIA_MASIVA_EVENTO(
    P_ID_EVENTO INT,
    P_ESTUDIANTES_PRESENTES INT[]
)
LANGUAGE PLPGSQL AS $$
BEGIN
    -- ELIMINAR REGISTRO EXISTENTES PARA ESTE EVENTO
    DELETE FROM ASISTENCIA_EVENTOS WHERE ID_EVENTO = P_ID_EVENTO;

    -- INSERTAR NUEVOS REGUSTROS DE ASISTENCIA
    INSERT INTO ASISTENCIA_EVENTOS (ID_EVENTO, ID_USUARIO, ASISTENCIA)
    SELECT P_ID_EVENTO, ID_ESTUDIANTE, TRUE
    FROM  UNNEST(P_ESTUDIANTES_PRESENTES) AS ID_ESTUDIANTE;

    -- OTORGAR TOKENS POR ASISTENCIA SI CORRESPONDE
    UPDATE USUARIO_TOKENS UT
    SET BALANCE = BALANCE + (SELECT TOKENS_OTORGADOS FROM EVENTOS WHERE ID_EVENTO = P_ID_EVENTO),
        ULTIMA_ACTUALIZACION = NOW()
    FROM UNNEST(P_ESTUDIANTES_PRESENTES) AS ID_ESTUDIANTE
    WHERE UT.ID_USUARIO = ID_ESTUDIANTE;
END;
$$;

-- GENERAR REPORTE COMPLETO DE CLASE
CREATE OR REPLACE PROCEDURE GENERAR_REPORTE_CLASE(
    P_ID_CLASE INT,
    OUT TOTAL_ESTUDIANTES INT,
    OUT PROMEDIO_GENERAL DECIMAL(5,2),
    OUT TASA_ASISTENCIA DECIMAL (5,2)
)
LANGUAGE PLPGSQL AS $$
BEGIN
    -- CONTAR ESTUDIANTES EN LA CLASE
    SELECT COUNT(*) INTO TOTAL_ESTUDIANTES
    FROM ESTUDIANTES_CLASES
    WHERE ID_CLASE = P_ID_CLASE;

    -- CALCULAR PROMEDIO DE CALIFICACIONES
    SELECT AVG(CALIFICACION) INTO PROMEDIO_GENERAL
    FROM CALIFICACIONES C
    JOIN ASIGNACIONES A ON C.ID_ASIGNACION = A.ID_ASIGNACION
    WHERE A.ID_CLASE = P_ID_CLASE;

    -- CALCULAR TASA DE ASISTENCIA A EVENTOS DE LA CLASE
    SELECT
        (COUNT(CASE WHEN AE.ASISTENCIA = TRUE THEN 1 END) * 100.00 /
        NULLIF(COUNT(AE.ID-ASISTENCIA), 0) INTO TASA_ASISTENCIA)
    FROM ASISTENCIA_EVENTOS AE
    JOIN EVENTOS E ON AE.ID_EVENTO = E.ID_EVENTO
    WHERE E.ID_CLASE = P_ID_CLASE;
END;
$$;

-- CANJEAR REXOMPENSA CON VALIDACION
CREATE OR REPLACE PROCEDURE CANJEAR_RECOMPENSA(
    P_ID_USUARIO INT,
    P_ID_RECOMPENSA INT
)
LANGUAGE PLPGSQL AS $$
DECLARE
    V_COSTO INT;
    V_BALANCE INT;
BEGIN
    -- OBTENER COSTO DE LA RECOMPENSA
    SELECT COSTO_TOKENS INTO V_COSTO FROM RECOMPENSAS
    WHERE ID_RECOMPENSA = P_ID_RECOMPENSA AND ACTIVO = TRUE;

    IF NOT FOUND THEN
        RAISE EXCEPTION 'RECOMPENSA NO DISPONIBLE';
    END IF;

    -- VERIFICAR SALDO
    SELECT BALANCEC INTO V_BALANCE FROM USUARIO_TOKENS
    WHERE ID_USUARIO = P_ID_USUARIO;

    IF V_BALANCE >= V_COSTO THEN
        -- REGISTRAR TRANSACCION
        INSERT INTO TRANSACCION_TOKENS (ID_USUARIO, MONTO, TIPO, ID_REFERENCIA, TIPO_REFERENCIA)
        VALUES (P_ID_USUARIO, V_COSTO, 'GASTADO', P_ID_RECOMPENSA, 'RECOMPENSA');

    -- REGISTRA CANJE (OPCIONAL: CREAR TABLA RECOMPENSAS_CANJEADAS)
        /*
        INSERT INTO RECOMPENSAS_CANJEADAS (ID_USUARIO, ID_RECOMPENSA, FECHA)
        VALUES (P_ID_USUARIO, P_ID_RECOMPENSA, NOW());
    ELSE
        RAISE EXCEPTION 'SALDO INSUFICIENTE PARA CANJEAR ESTA RECOMPENSA';
    */
    END IF;
END;
$$;

---------------------------- FUNCIONES EXTRA ---------------------------------

-- CALCULAR PROMEDIO DE ESTUDIANTE
CREATE OR REPLACE FUNCTION FN_CALCULAR_PROMEDIO_ESTUDIANTE(
    P_ID_ESTUDIANTE INT,
    P_ID_CLASE INT DEFAULT NULL
)
RETURNS DECIMAL (5,2) AS $$
DECLARE
    V_PROMEDIO DECIMAL (5,2);
BEGIN
    IF P_ID_CLASE IS NULL THEN
        SELECT AVG(CALIFICACION) INTO V_PROMEDIO
        FROM CALIFICACIONES
        WHERE ID_ESTUDIANTE = P_ID_ESTUDIANTE;
    ELSE
        SELECT AVG(C.CALIFICACION) INTO V_PROMEDIO
        FROM CALIFICACIONES C
        JOIN ASIGNACIONES A ON C.ID_ASIGNACION = A.ID_ASIGNACION
        WHERE C.ID_ESTUDIANTE = P_ID_ESTUDIANTE AND A.ID_CLASE = P_ID_CLASE;
    END IF;

    RETURN COALESCE(V_PROMEDIO, 0);
END;
$$ LANGUAGE PLPGSQL;

-- VERIFICAR DISPONIBILIDAD DE RECOMPENSA
CREATE OR REPLACE FUNCTION FN_RECOMPENSA_DISPONIBLE(
    P_ID_USUARIO INT,
    P_ID_RECOMPENSA INT
)
RETURNS BOOLEAN AS $$
DECLARE
    V_COSTO INT;
    V_BALANCE INT;
BEGIN
    SELECT COSTO_TOKENS INTO V_COSTO FROM REXOMPENSAS
    WHERE ID_RECOMPENSA = P_ID_RECOMPENSA AND ACTIVO = TRUE;

    SELECT BALANCE INTO V_BALANCE FROM USUARIO_TOKENS
    WHERE ID_USUARIO = P_ID_USUARIO;

    RETURN (V_BALANCE >= V_COSTO) AND (V_COSTO IS NOT NULL);
END;
$$ LANGUAGE PLPGSQL;